Both attacks are entirely preventable. The main problem with the first attack is that printing user-input strings should
\emph{not} be done with {\tt printf(str)}, rather {\tt printf("\%s", str)}. The fact that {\tt printf} is able to write
to aribrary memory addresses is also a problem. This is actually a useful feature of the function, allowing outputs to
be aligned, for instance {\tt printf("\%s: \%n\%d\textbackslash n", "Next number", \&offset, 5);
printf("\%*s\%s\textbackslash n", offset, "", "\textasciicircum This is the third prime!")} will align the {\tt
\textasciicircum} character such that it points at the 5. Arguably, this behavior isn't necessary, since the return
value of {\tt printf} is the number of characters printed in the entire statement, so the functionality is replaceable,
but removing functionality from any part of the C standard IO library is almost certainly a bad idea. Using the
canonical {\tt printf("\%s", str)} is probably a better option. Also, regardless of how securely a program seems to have
been written, user input should always be assumed dangerous until it has been checked. If for some reason the input must
be passed directly, it could be sanitised by either doubling up or removing all \% characters, but we see no
circumstances under which this would actually be necessary.

The second attack has a plethora of countermeasures. Buffer overflows and NOP sleds have a long and sordid history, so
significant time and effort has been spent on countering them. The most popular countermeasure, used by default in
modern versions of gcc, is the stack canary. A randomly selected value is pushed on the stack between the function's
local variables and return address, and also stored elsewhere. In order to overwrite the return address, an attack would
also need to overwrite the canary. If, when returning from the function, it appears that the canary has changed, then
the program will immediately crash. Guessing the value of the canary is usually very difficult, so overwriting it with
itself is not feasible.

This, however, distracts from a more important issue. Using {\tt strcpy} is a really bad idea, since it will copy data
until it reaches a null byte. Since we can't be sure that a user-input string will contain a null byte before the end of
the buffer, we sould never use it to process user input. Instead, {\tt strncpy}, the safer version, should be used.
Indeed, various tools exist which discourage or circumvent the usage of unsafe functions.
%http://gcc.gnu.org/ml/gcc-patches/2004-09/msg02055.html
{\tt --DFORTIFY\_SOURCE=1}, available in versions of gcc later than 4.0, will attempt to replace any unsafe functions
with their safe equivalents. Including {\tt banned.h} from Microsoft
%http://www.microsoft.com/en-gb/download/details.aspx?id=24817
will cause programs to flat out not compile if they attempt to use any unsafe functions. The {\tt splint} utility will
also detect potential buffer overflows in programs and inform the developer. {\tt strcpy} should generally not be used
anywhere, and if it is it should only be in situations where we can ensure that buffers cannot possibly overflow.

Further, there are almost no legitimate situations in which code placed on the stack should be executable. Most modern
processors support NX regions, areas of memory marked out as non-executable, causing a program to immediately crash if
execution jumps to somewhere it shouldn't. Interestingly, Ubuntu 9.11 with the i386 architecture should have an
emulation of this feature enabled by default. %https://wiki.ubuntu.com/Security/Features#nx
Presumably this was disabled on the VMs for the purposes of these labs. This feature, properly used, neatly stops most
code payloads from executing.

Also, a NOP sled involves executing a large number of NOP instructions. Very few programs become more efficient by using
NOPs,%http://www.steike.com/code/useless/zip-file-quine/
and it is highly unlikely that a legitimate program will spend its processor time doing nothing at all. A real-world NOP
sled will usually use instructions that do nothing in a ``busy" way, %http://en.wikipedia.org/wiki/NOP_sled
since programs executing lots of NOPs are suspicious and can be easily spotted.

